// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'app_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$AppFailure {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AppFailure);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AppFailure()';
}


}

/// @nodoc
class $AppFailureCopyWith<$Res>  {
$AppFailureCopyWith(AppFailure _, $Res Function(AppFailure) __);
}


/// Adds pattern-matching-related methods to [AppFailure].
extension AppFailurePatterns on AppFailure {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _NetworkUnreachable value)?  networkUnreachable,TResult Function( _ConnectionTimeout value)?  connectionTimeout,TResult Function( _ServerError value)?  serverError,TResult Function( _Unauthorized value)?  unauthorized,TResult Function( _Forbidden value)?  forbidden,TResult Function( _NotFound value)?  notFound,TResult Function( _BadRequest value)?  badRequest,TResult Function( _ParseError value)?  parseError,TResult Function( _ValidationError value)?  validationError,TResult Function( _RuleParseError value)?  ruleParseError,TResult Function( _RuleExecutionError value)?  ruleExecutionError,TResult Function( _SelectorError value)?  selectorError,TResult Function( _WeakPassword value)?  weakPassword,TResult Function( _UsernameExists value)?  usernameExists,TResult Function( _DatabaseError value)?  databaseError,TResult Function( _CacheError value)?  cacheError,TResult Function( _ServerSideMessage value)?  serverSideMessage,TResult Function( _Unknown value)?  unknown,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _NetworkUnreachable() when networkUnreachable != null:
return networkUnreachable(_that);case _ConnectionTimeout() when connectionTimeout != null:
return connectionTimeout(_that);case _ServerError() when serverError != null:
return serverError(_that);case _Unauthorized() when unauthorized != null:
return unauthorized(_that);case _Forbidden() when forbidden != null:
return forbidden(_that);case _NotFound() when notFound != null:
return notFound(_that);case _BadRequest() when badRequest != null:
return badRequest(_that);case _ParseError() when parseError != null:
return parseError(_that);case _ValidationError() when validationError != null:
return validationError(_that);case _RuleParseError() when ruleParseError != null:
return ruleParseError(_that);case _RuleExecutionError() when ruleExecutionError != null:
return ruleExecutionError(_that);case _SelectorError() when selectorError != null:
return selectorError(_that);case _WeakPassword() when weakPassword != null:
return weakPassword(_that);case _UsernameExists() when usernameExists != null:
return usernameExists(_that);case _DatabaseError() when databaseError != null:
return databaseError(_that);case _CacheError() when cacheError != null:
return cacheError(_that);case _ServerSideMessage() when serverSideMessage != null:
return serverSideMessage(_that);case _Unknown() when unknown != null:
return unknown(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _NetworkUnreachable value)  networkUnreachable,required TResult Function( _ConnectionTimeout value)  connectionTimeout,required TResult Function( _ServerError value)  serverError,required TResult Function( _Unauthorized value)  unauthorized,required TResult Function( _Forbidden value)  forbidden,required TResult Function( _NotFound value)  notFound,required TResult Function( _BadRequest value)  badRequest,required TResult Function( _ParseError value)  parseError,required TResult Function( _ValidationError value)  validationError,required TResult Function( _RuleParseError value)  ruleParseError,required TResult Function( _RuleExecutionError value)  ruleExecutionError,required TResult Function( _SelectorError value)  selectorError,required TResult Function( _WeakPassword value)  weakPassword,required TResult Function( _UsernameExists value)  usernameExists,required TResult Function( _DatabaseError value)  databaseError,required TResult Function( _CacheError value)  cacheError,required TResult Function( _ServerSideMessage value)  serverSideMessage,required TResult Function( _Unknown value)  unknown,}){
final _that = this;
switch (_that) {
case _NetworkUnreachable():
return networkUnreachable(_that);case _ConnectionTimeout():
return connectionTimeout(_that);case _ServerError():
return serverError(_that);case _Unauthorized():
return unauthorized(_that);case _Forbidden():
return forbidden(_that);case _NotFound():
return notFound(_that);case _BadRequest():
return badRequest(_that);case _ParseError():
return parseError(_that);case _ValidationError():
return validationError(_that);case _RuleParseError():
return ruleParseError(_that);case _RuleExecutionError():
return ruleExecutionError(_that);case _SelectorError():
return selectorError(_that);case _WeakPassword():
return weakPassword(_that);case _UsernameExists():
return usernameExists(_that);case _DatabaseError():
return databaseError(_that);case _CacheError():
return cacheError(_that);case _ServerSideMessage():
return serverSideMessage(_that);case _Unknown():
return unknown(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _NetworkUnreachable value)?  networkUnreachable,TResult? Function( _ConnectionTimeout value)?  connectionTimeout,TResult? Function( _ServerError value)?  serverError,TResult? Function( _Unauthorized value)?  unauthorized,TResult? Function( _Forbidden value)?  forbidden,TResult? Function( _NotFound value)?  notFound,TResult? Function( _BadRequest value)?  badRequest,TResult? Function( _ParseError value)?  parseError,TResult? Function( _ValidationError value)?  validationError,TResult? Function( _RuleParseError value)?  ruleParseError,TResult? Function( _RuleExecutionError value)?  ruleExecutionError,TResult? Function( _SelectorError value)?  selectorError,TResult? Function( _WeakPassword value)?  weakPassword,TResult? Function( _UsernameExists value)?  usernameExists,TResult? Function( _DatabaseError value)?  databaseError,TResult? Function( _CacheError value)?  cacheError,TResult? Function( _ServerSideMessage value)?  serverSideMessage,TResult? Function( _Unknown value)?  unknown,}){
final _that = this;
switch (_that) {
case _NetworkUnreachable() when networkUnreachable != null:
return networkUnreachable(_that);case _ConnectionTimeout() when connectionTimeout != null:
return connectionTimeout(_that);case _ServerError() when serverError != null:
return serverError(_that);case _Unauthorized() when unauthorized != null:
return unauthorized(_that);case _Forbidden() when forbidden != null:
return forbidden(_that);case _NotFound() when notFound != null:
return notFound(_that);case _BadRequest() when badRequest != null:
return badRequest(_that);case _ParseError() when parseError != null:
return parseError(_that);case _ValidationError() when validationError != null:
return validationError(_that);case _RuleParseError() when ruleParseError != null:
return ruleParseError(_that);case _RuleExecutionError() when ruleExecutionError != null:
return ruleExecutionError(_that);case _SelectorError() when selectorError != null:
return selectorError(_that);case _WeakPassword() when weakPassword != null:
return weakPassword(_that);case _UsernameExists() when usernameExists != null:
return usernameExists(_that);case _DatabaseError() when databaseError != null:
return databaseError(_that);case _CacheError() when cacheError != null:
return cacheError(_that);case _ServerSideMessage() when serverSideMessage != null:
return serverSideMessage(_that);case _Unknown() when unknown != null:
return unknown(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  networkUnreachable,TResult Function()?  connectionTimeout,TResult Function( int? statusCode)?  serverError,TResult Function()?  unauthorized,TResult Function()?  forbidden,TResult Function()?  notFound,TResult Function( String? details)?  badRequest,TResult Function( String? details)?  parseError,TResult Function( String message)?  validationError,TResult Function( String message)?  ruleParseError,TResult Function( String message)?  ruleExecutionError,TResult Function( String selector,  String? details)?  selectorError,TResult Function( int minLength)?  weakPassword,TResult Function( String username)?  usernameExists,TResult Function( String? details)?  databaseError,TResult Function( String? details)?  cacheError,TResult Function( String message)?  serverSideMessage,TResult Function( Object? originalError)?  unknown,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _NetworkUnreachable() when networkUnreachable != null:
return networkUnreachable();case _ConnectionTimeout() when connectionTimeout != null:
return connectionTimeout();case _ServerError() when serverError != null:
return serverError(_that.statusCode);case _Unauthorized() when unauthorized != null:
return unauthorized();case _Forbidden() when forbidden != null:
return forbidden();case _NotFound() when notFound != null:
return notFound();case _BadRequest() when badRequest != null:
return badRequest(_that.details);case _ParseError() when parseError != null:
return parseError(_that.details);case _ValidationError() when validationError != null:
return validationError(_that.message);case _RuleParseError() when ruleParseError != null:
return ruleParseError(_that.message);case _RuleExecutionError() when ruleExecutionError != null:
return ruleExecutionError(_that.message);case _SelectorError() when selectorError != null:
return selectorError(_that.selector,_that.details);case _WeakPassword() when weakPassword != null:
return weakPassword(_that.minLength);case _UsernameExists() when usernameExists != null:
return usernameExists(_that.username);case _DatabaseError() when databaseError != null:
return databaseError(_that.details);case _CacheError() when cacheError != null:
return cacheError(_that.details);case _ServerSideMessage() when serverSideMessage != null:
return serverSideMessage(_that.message);case _Unknown() when unknown != null:
return unknown(_that.originalError);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  networkUnreachable,required TResult Function()  connectionTimeout,required TResult Function( int? statusCode)  serverError,required TResult Function()  unauthorized,required TResult Function()  forbidden,required TResult Function()  notFound,required TResult Function( String? details)  badRequest,required TResult Function( String? details)  parseError,required TResult Function( String message)  validationError,required TResult Function( String message)  ruleParseError,required TResult Function( String message)  ruleExecutionError,required TResult Function( String selector,  String? details)  selectorError,required TResult Function( int minLength)  weakPassword,required TResult Function( String username)  usernameExists,required TResult Function( String? details)  databaseError,required TResult Function( String? details)  cacheError,required TResult Function( String message)  serverSideMessage,required TResult Function( Object? originalError)  unknown,}) {final _that = this;
switch (_that) {
case _NetworkUnreachable():
return networkUnreachable();case _ConnectionTimeout():
return connectionTimeout();case _ServerError():
return serverError(_that.statusCode);case _Unauthorized():
return unauthorized();case _Forbidden():
return forbidden();case _NotFound():
return notFound();case _BadRequest():
return badRequest(_that.details);case _ParseError():
return parseError(_that.details);case _ValidationError():
return validationError(_that.message);case _RuleParseError():
return ruleParseError(_that.message);case _RuleExecutionError():
return ruleExecutionError(_that.message);case _SelectorError():
return selectorError(_that.selector,_that.details);case _WeakPassword():
return weakPassword(_that.minLength);case _UsernameExists():
return usernameExists(_that.username);case _DatabaseError():
return databaseError(_that.details);case _CacheError():
return cacheError(_that.details);case _ServerSideMessage():
return serverSideMessage(_that.message);case _Unknown():
return unknown(_that.originalError);}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  networkUnreachable,TResult? Function()?  connectionTimeout,TResult? Function( int? statusCode)?  serverError,TResult? Function()?  unauthorized,TResult? Function()?  forbidden,TResult? Function()?  notFound,TResult? Function( String? details)?  badRequest,TResult? Function( String? details)?  parseError,TResult? Function( String message)?  validationError,TResult? Function( String message)?  ruleParseError,TResult? Function( String message)?  ruleExecutionError,TResult? Function( String selector,  String? details)?  selectorError,TResult? Function( int minLength)?  weakPassword,TResult? Function( String username)?  usernameExists,TResult? Function( String? details)?  databaseError,TResult? Function( String? details)?  cacheError,TResult? Function( String message)?  serverSideMessage,TResult? Function( Object? originalError)?  unknown,}) {final _that = this;
switch (_that) {
case _NetworkUnreachable() when networkUnreachable != null:
return networkUnreachable();case _ConnectionTimeout() when connectionTimeout != null:
return connectionTimeout();case _ServerError() when serverError != null:
return serverError(_that.statusCode);case _Unauthorized() when unauthorized != null:
return unauthorized();case _Forbidden() when forbidden != null:
return forbidden();case _NotFound() when notFound != null:
return notFound();case _BadRequest() when badRequest != null:
return badRequest(_that.details);case _ParseError() when parseError != null:
return parseError(_that.details);case _ValidationError() when validationError != null:
return validationError(_that.message);case _RuleParseError() when ruleParseError != null:
return ruleParseError(_that.message);case _RuleExecutionError() when ruleExecutionError != null:
return ruleExecutionError(_that.message);case _SelectorError() when selectorError != null:
return selectorError(_that.selector,_that.details);case _WeakPassword() when weakPassword != null:
return weakPassword(_that.minLength);case _UsernameExists() when usernameExists != null:
return usernameExists(_that.username);case _DatabaseError() when databaseError != null:
return databaseError(_that.details);case _CacheError() when cacheError != null:
return cacheError(_that.details);case _ServerSideMessage() when serverSideMessage != null:
return serverSideMessage(_that.message);case _Unknown() when unknown != null:
return unknown(_that.originalError);case _:
  return null;

}
}

}

/// @nodoc


class _NetworkUnreachable implements AppFailure {
  const _NetworkUnreachable();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NetworkUnreachable);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AppFailure.networkUnreachable()';
}


}




/// @nodoc


class _ConnectionTimeout implements AppFailure {
  const _ConnectionTimeout();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ConnectionTimeout);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AppFailure.connectionTimeout()';
}


}




/// @nodoc


class _ServerError implements AppFailure {
  const _ServerError({this.statusCode});
  

 final  int? statusCode;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ServerErrorCopyWith<_ServerError> get copyWith => __$ServerErrorCopyWithImpl<_ServerError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ServerError&&(identical(other.statusCode, statusCode) || other.statusCode == statusCode));
}


@override
int get hashCode => Object.hash(runtimeType,statusCode);

@override
String toString() {
  return 'AppFailure.serverError(statusCode: $statusCode)';
}


}

/// @nodoc
abstract mixin class _$ServerErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$ServerErrorCopyWith(_ServerError value, $Res Function(_ServerError) _then) = __$ServerErrorCopyWithImpl;
@useResult
$Res call({
 int? statusCode
});




}
/// @nodoc
class __$ServerErrorCopyWithImpl<$Res>
    implements _$ServerErrorCopyWith<$Res> {
  __$ServerErrorCopyWithImpl(this._self, this._then);

  final _ServerError _self;
  final $Res Function(_ServerError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? statusCode = freezed,}) {
  return _then(_ServerError(
statusCode: freezed == statusCode ? _self.statusCode : statusCode // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

/// @nodoc


class _Unauthorized implements AppFailure {
  const _Unauthorized();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Unauthorized);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AppFailure.unauthorized()';
}


}




/// @nodoc


class _Forbidden implements AppFailure {
  const _Forbidden();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Forbidden);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AppFailure.forbidden()';
}


}




/// @nodoc


class _NotFound implements AppFailure {
  const _NotFound();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotFound);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AppFailure.notFound()';
}


}




/// @nodoc


class _BadRequest implements AppFailure {
  const _BadRequest({this.details});
  

 final  String? details;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BadRequestCopyWith<_BadRequest> get copyWith => __$BadRequestCopyWithImpl<_BadRequest>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BadRequest&&(identical(other.details, details) || other.details == details));
}


@override
int get hashCode => Object.hash(runtimeType,details);

@override
String toString() {
  return 'AppFailure.badRequest(details: $details)';
}


}

/// @nodoc
abstract mixin class _$BadRequestCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$BadRequestCopyWith(_BadRequest value, $Res Function(_BadRequest) _then) = __$BadRequestCopyWithImpl;
@useResult
$Res call({
 String? details
});




}
/// @nodoc
class __$BadRequestCopyWithImpl<$Res>
    implements _$BadRequestCopyWith<$Res> {
  __$BadRequestCopyWithImpl(this._self, this._then);

  final _BadRequest _self;
  final $Res Function(_BadRequest) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? details = freezed,}) {
  return _then(_BadRequest(
details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

/// @nodoc


class _ParseError implements AppFailure {
  const _ParseError({this.details});
  

 final  String? details;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ParseErrorCopyWith<_ParseError> get copyWith => __$ParseErrorCopyWithImpl<_ParseError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ParseError&&(identical(other.details, details) || other.details == details));
}


@override
int get hashCode => Object.hash(runtimeType,details);

@override
String toString() {
  return 'AppFailure.parseError(details: $details)';
}


}

/// @nodoc
abstract mixin class _$ParseErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$ParseErrorCopyWith(_ParseError value, $Res Function(_ParseError) _then) = __$ParseErrorCopyWithImpl;
@useResult
$Res call({
 String? details
});




}
/// @nodoc
class __$ParseErrorCopyWithImpl<$Res>
    implements _$ParseErrorCopyWith<$Res> {
  __$ParseErrorCopyWithImpl(this._self, this._then);

  final _ParseError _self;
  final $Res Function(_ParseError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? details = freezed,}) {
  return _then(_ParseError(
details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

/// @nodoc


class _ValidationError implements AppFailure {
  const _ValidationError({required this.message});
  

 final  String message;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ValidationErrorCopyWith<_ValidationError> get copyWith => __$ValidationErrorCopyWithImpl<_ValidationError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ValidationError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AppFailure.validationError(message: $message)';
}


}

/// @nodoc
abstract mixin class _$ValidationErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$ValidationErrorCopyWith(_ValidationError value, $Res Function(_ValidationError) _then) = __$ValidationErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$ValidationErrorCopyWithImpl<$Res>
    implements _$ValidationErrorCopyWith<$Res> {
  __$ValidationErrorCopyWithImpl(this._self, this._then);

  final _ValidationError _self;
  final $Res Function(_ValidationError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_ValidationError(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _RuleParseError implements AppFailure {
  const _RuleParseError({required this.message});
  

 final  String message;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RuleParseErrorCopyWith<_RuleParseError> get copyWith => __$RuleParseErrorCopyWithImpl<_RuleParseError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RuleParseError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AppFailure.ruleParseError(message: $message)';
}


}

/// @nodoc
abstract mixin class _$RuleParseErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$RuleParseErrorCopyWith(_RuleParseError value, $Res Function(_RuleParseError) _then) = __$RuleParseErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$RuleParseErrorCopyWithImpl<$Res>
    implements _$RuleParseErrorCopyWith<$Res> {
  __$RuleParseErrorCopyWithImpl(this._self, this._then);

  final _RuleParseError _self;
  final $Res Function(_RuleParseError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_RuleParseError(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _RuleExecutionError implements AppFailure {
  const _RuleExecutionError({required this.message});
  

 final  String message;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RuleExecutionErrorCopyWith<_RuleExecutionError> get copyWith => __$RuleExecutionErrorCopyWithImpl<_RuleExecutionError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RuleExecutionError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AppFailure.ruleExecutionError(message: $message)';
}


}

/// @nodoc
abstract mixin class _$RuleExecutionErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$RuleExecutionErrorCopyWith(_RuleExecutionError value, $Res Function(_RuleExecutionError) _then) = __$RuleExecutionErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$RuleExecutionErrorCopyWithImpl<$Res>
    implements _$RuleExecutionErrorCopyWith<$Res> {
  __$RuleExecutionErrorCopyWithImpl(this._self, this._then);

  final _RuleExecutionError _self;
  final $Res Function(_RuleExecutionError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_RuleExecutionError(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _SelectorError implements AppFailure {
  const _SelectorError({required this.selector, this.details});
  

 final  String selector;
 final  String? details;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectorErrorCopyWith<_SelectorError> get copyWith => __$SelectorErrorCopyWithImpl<_SelectorError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectorError&&(identical(other.selector, selector) || other.selector == selector)&&(identical(other.details, details) || other.details == details));
}


@override
int get hashCode => Object.hash(runtimeType,selector,details);

@override
String toString() {
  return 'AppFailure.selectorError(selector: $selector, details: $details)';
}


}

/// @nodoc
abstract mixin class _$SelectorErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$SelectorErrorCopyWith(_SelectorError value, $Res Function(_SelectorError) _then) = __$SelectorErrorCopyWithImpl;
@useResult
$Res call({
 String selector, String? details
});




}
/// @nodoc
class __$SelectorErrorCopyWithImpl<$Res>
    implements _$SelectorErrorCopyWith<$Res> {
  __$SelectorErrorCopyWithImpl(this._self, this._then);

  final _SelectorError _self;
  final $Res Function(_SelectorError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? selector = null,Object? details = freezed,}) {
  return _then(_SelectorError(
selector: null == selector ? _self.selector : selector // ignore: cast_nullable_to_non_nullable
as String,details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

/// @nodoc


class _WeakPassword implements AppFailure {
  const _WeakPassword({required this.minLength});
  

 final  int minLength;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WeakPasswordCopyWith<_WeakPassword> get copyWith => __$WeakPasswordCopyWithImpl<_WeakPassword>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WeakPassword&&(identical(other.minLength, minLength) || other.minLength == minLength));
}


@override
int get hashCode => Object.hash(runtimeType,minLength);

@override
String toString() {
  return 'AppFailure.weakPassword(minLength: $minLength)';
}


}

/// @nodoc
abstract mixin class _$WeakPasswordCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$WeakPasswordCopyWith(_WeakPassword value, $Res Function(_WeakPassword) _then) = __$WeakPasswordCopyWithImpl;
@useResult
$Res call({
 int minLength
});




}
/// @nodoc
class __$WeakPasswordCopyWithImpl<$Res>
    implements _$WeakPasswordCopyWith<$Res> {
  __$WeakPasswordCopyWithImpl(this._self, this._then);

  final _WeakPassword _self;
  final $Res Function(_WeakPassword) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? minLength = null,}) {
  return _then(_WeakPassword(
minLength: null == minLength ? _self.minLength : minLength // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class _UsernameExists implements AppFailure {
  const _UsernameExists({required this.username});
  

 final  String username;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UsernameExistsCopyWith<_UsernameExists> get copyWith => __$UsernameExistsCopyWithImpl<_UsernameExists>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UsernameExists&&(identical(other.username, username) || other.username == username));
}


@override
int get hashCode => Object.hash(runtimeType,username);

@override
String toString() {
  return 'AppFailure.usernameExists(username: $username)';
}


}

/// @nodoc
abstract mixin class _$UsernameExistsCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$UsernameExistsCopyWith(_UsernameExists value, $Res Function(_UsernameExists) _then) = __$UsernameExistsCopyWithImpl;
@useResult
$Res call({
 String username
});




}
/// @nodoc
class __$UsernameExistsCopyWithImpl<$Res>
    implements _$UsernameExistsCopyWith<$Res> {
  __$UsernameExistsCopyWithImpl(this._self, this._then);

  final _UsernameExists _self;
  final $Res Function(_UsernameExists) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? username = null,}) {
  return _then(_UsernameExists(
username: null == username ? _self.username : username // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _DatabaseError implements AppFailure {
  const _DatabaseError({this.details});
  

 final  String? details;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DatabaseErrorCopyWith<_DatabaseError> get copyWith => __$DatabaseErrorCopyWithImpl<_DatabaseError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DatabaseError&&(identical(other.details, details) || other.details == details));
}


@override
int get hashCode => Object.hash(runtimeType,details);

@override
String toString() {
  return 'AppFailure.databaseError(details: $details)';
}


}

/// @nodoc
abstract mixin class _$DatabaseErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$DatabaseErrorCopyWith(_DatabaseError value, $Res Function(_DatabaseError) _then) = __$DatabaseErrorCopyWithImpl;
@useResult
$Res call({
 String? details
});




}
/// @nodoc
class __$DatabaseErrorCopyWithImpl<$Res>
    implements _$DatabaseErrorCopyWith<$Res> {
  __$DatabaseErrorCopyWithImpl(this._self, this._then);

  final _DatabaseError _self;
  final $Res Function(_DatabaseError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? details = freezed,}) {
  return _then(_DatabaseError(
details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

/// @nodoc


class _CacheError implements AppFailure {
  const _CacheError({this.details});
  

 final  String? details;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CacheErrorCopyWith<_CacheError> get copyWith => __$CacheErrorCopyWithImpl<_CacheError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CacheError&&(identical(other.details, details) || other.details == details));
}


@override
int get hashCode => Object.hash(runtimeType,details);

@override
String toString() {
  return 'AppFailure.cacheError(details: $details)';
}


}

/// @nodoc
abstract mixin class _$CacheErrorCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$CacheErrorCopyWith(_CacheError value, $Res Function(_CacheError) _then) = __$CacheErrorCopyWithImpl;
@useResult
$Res call({
 String? details
});




}
/// @nodoc
class __$CacheErrorCopyWithImpl<$Res>
    implements _$CacheErrorCopyWith<$Res> {
  __$CacheErrorCopyWithImpl(this._self, this._then);

  final _CacheError _self;
  final $Res Function(_CacheError) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? details = freezed,}) {
  return _then(_CacheError(
details: freezed == details ? _self.details : details // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

/// @nodoc


class _ServerSideMessage implements AppFailure {
  const _ServerSideMessage({required this.message});
  

 final  String message;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ServerSideMessageCopyWith<_ServerSideMessage> get copyWith => __$ServerSideMessageCopyWithImpl<_ServerSideMessage>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ServerSideMessage&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AppFailure.serverSideMessage(message: $message)';
}


}

/// @nodoc
abstract mixin class _$ServerSideMessageCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$ServerSideMessageCopyWith(_ServerSideMessage value, $Res Function(_ServerSideMessage) _then) = __$ServerSideMessageCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$ServerSideMessageCopyWithImpl<$Res>
    implements _$ServerSideMessageCopyWith<$Res> {
  __$ServerSideMessageCopyWithImpl(this._self, this._then);

  final _ServerSideMessage _self;
  final $Res Function(_ServerSideMessage) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_ServerSideMessage(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _Unknown implements AppFailure {
  const _Unknown(this.originalError);
  

 final  Object? originalError;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnknownCopyWith<_Unknown> get copyWith => __$UnknownCopyWithImpl<_Unknown>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Unknown&&const DeepCollectionEquality().equals(other.originalError, originalError));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(originalError));

@override
String toString() {
  return 'AppFailure.unknown(originalError: $originalError)';
}


}

/// @nodoc
abstract mixin class _$UnknownCopyWith<$Res> implements $AppFailureCopyWith<$Res> {
  factory _$UnknownCopyWith(_Unknown value, $Res Function(_Unknown) _then) = __$UnknownCopyWithImpl;
@useResult
$Res call({
 Object? originalError
});




}
/// @nodoc
class __$UnknownCopyWithImpl<$Res>
    implements _$UnknownCopyWith<$Res> {
  __$UnknownCopyWithImpl(this._self, this._then);

  final _Unknown _self;
  final $Res Function(_Unknown) _then;

/// Create a copy of AppFailure
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? originalError = freezed,}) {
  return _then(_Unknown(
freezed == originalError ? _self.originalError : originalError ,
  ));
}


}

// dart format on
