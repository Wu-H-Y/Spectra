// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'http_client.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `build_client`, `to_wreq`, `to_wreq`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// 发送 HTTP 请求。
///
/// 使用指定的浏览器模拟配置发送 HTTP 请求，
/// 支持 TLS 指纹伪装和 HTTP/2 指纹。
///
/// # Errors
///
/// 返回错误字符串，包含失败原因。
Future<HttpResponse> fetch({required HttpRequest request}) =>
    RustLib.instance.api.crateApiHttpClientFetch(request: request);

/// 快速 GET 请求 (使用默认配置)。
Future<HttpResponse> httpGet({required String url}) =>
    RustLib.instance.api.crateApiHttpClientHttpGet(url: url);

/// 快速 POST 请求 (使用默认配置)。
Future<HttpResponse> httpPost({required String url, required String body}) =>
    RustLib.instance.api.crateApiHttpClientHttpPost(url: url, body: body);

/// 快速请求 (使用指定模拟器)。
Future<HttpResponse> httpFetch({
  required String url,
  required Emulation emulation,
  required int timeoutMs,
}) => RustLib.instance.api.crateApiHttpClientHttpFetch(
  url: url,
  emulation: emulation,
  timeoutMs: timeoutMs,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HttpClient>>
abstract class HttpClient implements RustOpaqueInterface {
  /// 创建默认客户端。
  static Future<HttpClient> defaultClient() =>
      RustLib.instance.api.crateApiHttpClientHttpClientDefaultClient();

  /// GET 请求。
  Future<HttpResponse> get_({required String url});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// 创建新客户端。
  ///
  /// # Errors
  ///
  /// 返回错误字符串，包含失败原因。
  static Future<HttpClient> newInstance({required ClientSettings settings}) =>
      RustLib.instance.api.crateApiHttpClientHttpClientNew(settings: settings);

  /// POST 请求。
  Future<HttpResponse> post({required String url, required String body});

  /// 发送 HTTP 请求。
  ///
  /// # Errors
  ///
  /// 返回错误字符串，包含失败原因。
  Future<HttpResponse> request({required HttpRequest request});
}

/// 客户端配置。
class ClientSettings {
  /// 浏览器模拟 (简单模式)。
  final Emulation? emulation;

  /// 浏览器模拟 (高级模式)。
  final EmulationOption? emulationOption;

  /// Cookie 配置。
  final CookieSettings? cookieSettings;

  /// 超时配置。
  final TimeoutSettings? timeoutSettings;

  /// 代理配置。
  final ProxySettings? proxySettings;

  /// 重定向配置。
  final RedirectSettings? redirectSettings;

  /// User-Agent。
  final String? userAgent;

  const ClientSettings({
    this.emulation,
    this.emulationOption,
    this.cookieSettings,
    this.timeoutSettings,
    this.proxySettings,
    this.redirectSettings,
    this.userAgent,
  });

  static Future<ClientSettings> default_() =>
      RustLib.instance.api.crateApiHttpClientClientSettingsDefault();

  @override
  int get hashCode =>
      emulation.hashCode ^
      emulationOption.hashCode ^
      cookieSettings.hashCode ^
      timeoutSettings.hashCode ^
      proxySettings.hashCode ^
      redirectSettings.hashCode ^
      userAgent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientSettings &&
          runtimeType == other.runtimeType &&
          emulation == other.emulation &&
          emulationOption == other.emulationOption &&
          cookieSettings == other.cookieSettings &&
          timeoutSettings == other.timeoutSettings &&
          proxySettings == other.proxySettings &&
          redirectSettings == other.redirectSettings &&
          userAgent == other.userAgent;
}

/// Cookie 配置。
class CookieSettings {
  /// 是否存储 Cookie。
  final bool storeCookies;

  const CookieSettings({
    required this.storeCookies,
  });

  static Future<CookieSettings> default_() =>
      RustLib.instance.api.crateApiHttpClientCookieSettingsDefault();

  @override
  int get hashCode => storeCookies.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CookieSettings &&
          runtimeType == other.runtimeType &&
          storeCookies == other.storeCookies;
}

/// 浏览器设备模拟类型。
///
/// 提供常用浏览器的 TLS/HTTP2 指纹伪装。
enum Emulation {
  chrome131,
  chrome132,
  chrome133,
  chrome134,
  chrome135,
  chrome136,
  chrome120,
  chrome124,
  chrome126,
  chrome127,
  chrome128,
  chrome129,
  chrome130,
  safari18,
  safari182,
  safari183,
  safari185,
  safari26,
  safariIos1811,
  firefox133,
  firefox135,
  firefox136,
  firefox139,
  firefox142,
  firefox143,
  firefox144,
  firefox145,
  firefox146,
  firefox147,
  edge127,
  edge131,
  edge134,
  edge135,
  edge136,
  edge137,
  edge138,
  edge139,
  edge140,
  edge141,
  edge142,
  edge143,
  edge144,
  edge145,
  okHttp314,
  okHttp412,
  okHttp5,
  ;

  static Future<Emulation> default_() =>
      RustLib.instance.api.crateApiHttpClientEmulationDefault();
}

/// 浏览器模拟高级选项。
class EmulationOption {
  /// 浏览器版本。
  final Emulation? emulation;

  /// 操作系统。
  final EmulationOS? emulationOs;

  /// 是否跳过 HTTP/2 指纹。
  final bool? skipHttp2;

  /// 是否跳过默认请求头。
  final bool? skipHeaders;

  const EmulationOption({
    this.emulation,
    this.emulationOs,
    this.skipHttp2,
    this.skipHeaders,
  });

  static Future<EmulationOption> default_() =>
      RustLib.instance.api.crateApiHttpClientEmulationOptionDefault();

  @override
  int get hashCode =>
      emulation.hashCode ^
      emulationOs.hashCode ^
      skipHttp2.hashCode ^
      skipHeaders.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EmulationOption &&
          runtimeType == other.runtimeType &&
          emulation == other.emulation &&
          emulationOs == other.emulationOs &&
          skipHttp2 == other.skipHttp2 &&
          skipHeaders == other.skipHeaders;
}

/// 操作系统模拟类型。
enum EmulationOS {
  windows,
  macOs,
  linux,
  android,
  ios,
  ;

  static Future<EmulationOS> default_() =>
      RustLib.instance.api.crateApiHttpClientEmulationOsDefault();
}

/// HTTP 请求配置。
class HttpRequest {
  /// 请求 URL。
  final String url;

  /// HTTP 方法 (GET/POST/PUT/DELETE/HEAD)。
  final String method;

  /// 请求头。
  final Map<String, String>? headers;

  /// 请求体。
  final String? body;

  /// 浏览器模拟类型。
  final Emulation emulation;

  /// 超时时间 (毫秒)。
  final int timeoutMs;

  /// 是否跟随重定向。
  final bool followRedirects;

  const HttpRequest({
    required this.url,
    required this.method,
    this.headers,
    this.body,
    required this.emulation,
    required this.timeoutMs,
    required this.followRedirects,
  });

  static Future<HttpRequest> default_() =>
      RustLib.instance.api.crateApiHttpClientHttpRequestDefault();

  @override
  int get hashCode =>
      url.hashCode ^
      method.hashCode ^
      headers.hashCode ^
      body.hashCode ^
      emulation.hashCode ^
      timeoutMs.hashCode ^
      followRedirects.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is HttpRequest &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          method == other.method &&
          headers == other.headers &&
          body == other.body &&
          emulation == other.emulation &&
          timeoutMs == other.timeoutMs &&
          followRedirects == other.followRedirects;
}

/// HTTP 响应。
class HttpResponse {
  /// HTTP 状态码。
  final int status;

  /// 响应头。
  final Map<String, String> headers;

  /// 响应体。
  final String body;

  /// 最终 URL (重定向后)。
  final String url;

  const HttpResponse({
    required this.status,
    required this.headers,
    required this.body,
    required this.url,
  });

  @override
  int get hashCode =>
      status.hashCode ^ headers.hashCode ^ body.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is HttpResponse &&
          runtimeType == other.runtimeType &&
          status == other.status &&
          headers == other.headers &&
          body == other.body &&
          url == other.url;
}

/// 代理条件。
enum ProxyCondition {
  all,
  http,
  https,
  ;

  static Future<ProxyCondition> default_() =>
      RustLib.instance.api.crateApiHttpClientProxyConditionDefault();
}

/// 代理配置。
class ProxyConfig {
  /// 代理 URL。
  final String url;

  /// 代理条件。
  final ProxyCondition condition;

  const ProxyConfig({
    required this.url,
    required this.condition,
  });

  @override
  int get hashCode => url.hashCode ^ condition.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyConfig &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          condition == other.condition;
}

@freezed
sealed class ProxySettings with _$ProxySettings {
  const ProxySettings._();

  /// 不使用代理。
  const factory ProxySettings.noProxy() = ProxySettings_NoProxy;

  /// 自定义代理列表。
  const factory ProxySettings.custom(
    List<ProxyConfig> field0,
  ) = ProxySettings_Custom;

  static Future<ProxySettings> default_() =>
      RustLib.instance.api.crateApiHttpClientProxySettingsDefault();
}

@freezed
sealed class RedirectSettings with _$RedirectSettings {
  const RedirectSettings._();

  /// 不跟随重定向。
  const factory RedirectSettings.none() = RedirectSettings_None;

  /// 有限次重定向。
  const factory RedirectSettings.limited(
    int field0,
  ) = RedirectSettings_Limited;

  static Future<RedirectSettings> default_() =>
      RustLib.instance.api.crateApiHttpClientRedirectSettingsDefault();
}

/// 超时配置。
class TimeoutSettings {
  /// 请求超时 (毫秒)。
  final int? timeoutMs;

  /// 连接超时 (毫秒)。
  final int? connectTimeoutMs;

  const TimeoutSettings({
    this.timeoutMs,
    this.connectTimeoutMs,
  });

  static Future<TimeoutSettings> default_() =>
      RustLib.instance.api.crateApiHttpClientTimeoutSettingsDefault();

  @override
  int get hashCode => timeoutMs.hashCode ^ connectTimeoutMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimeoutSettings &&
          runtimeType == other.runtimeType &&
          timeoutMs == other.timeoutMs &&
          connectTimeoutMs == other.connectTimeoutMs;
}
